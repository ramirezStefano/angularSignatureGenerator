{"ast":null,"code":"import $45QHv$babelruntimehelpersesmextends from \"@babel/runtime/helpers/esm/extends\";\nimport { forwardRef as $45QHv$forwardRef, useState as $45QHv$useState, useRef as $45QHv$useRef, useEffect as $45QHv$useEffect, useCallback as $45QHv$useCallback, createElement as $45QHv$createElement } from \"react\";\nimport { useComposedRefs as $45QHv$useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { Primitive as $45QHv$Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef as $45QHv$useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nconst $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst $d3863c46a17e8a28$var$EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\nconst $d3863c46a17e8a28$var$FOCUS_SCOPE_NAME = 'FocusScope';\nconst $d3863c46a17e8a28$export$20e40289641fbbb6 = /*#__PURE__*/$45QHv$forwardRef((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container1, setContainer] = $45QHv$useState(null);\n  const onMountAutoFocus = $45QHv$useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = $45QHv$useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = $45QHv$useRef(null);\n  const composedRefs = $45QHv$useComposedRefs(forwardedRef, node => setContainer(node));\n  const focusScope = $45QHv$useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    }\n  }).current; // Takes care of trapping focus if focus is moved outside programmatically for example\n  $45QHv$useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event) {\n        if (focusScope.paused || !container1) return;\n        const target = event.target;\n        if (container1.contains(target)) lastFocusedElementRef.current = target;else $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n          select: true\n        });\n      }\n      function handleFocusOut(event) {\n        if (focusScope.paused || !container1) return;\n        const relatedTarget = event.relatedTarget; // A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:\n        //\n        // 1. When the user switches app/tabs/windows/the browser itself loses focus.\n        // 2. In Google Chrome, when the focused element is removed from the DOM.\n        //\n        // We let the browser do its thing here because:\n        //\n        // 1. The browser already keeps a memory of what's focused for when the page gets refocused.\n        // 2. In Google Chrome, if we try to focus the deleted focused element (as per below), it\n        //    throws the CPU to 100%, so we avoid doing anything for this reason here too.\n        if (relatedTarget === null) return; // If the focus has moved to an actual legitimate element (`relatedTarget !== null`)\n        // that is outside the container, we move focus to the last valid focused element inside.\n        if (!container1.contains(relatedTarget)) $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n          select: true\n        });\n      } // When the focused element gets removed from the DOM, browsers move focus\n      // back to the document.body. In this case, we move focus to the container\n      // to keep focus trapped correctly.\n      function handleMutations(mutations) {\n        const focusedElement = document.activeElement;\n        if (focusedElement !== document.body) return;\n        for (const mutation of mutations) if (mutation.removedNodes.length > 0) $d3863c46a17e8a28$var$focus(container1);\n      }\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      const mutationObserver = new MutationObserver(handleMutations);\n      if (container1) mutationObserver.observe(container1, {\n        childList: true,\n        subtree: true\n      });\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container1, focusScope.paused]);\n  $45QHv$useEffect(() => {\n    if (container1) {\n      $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement;\n      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n        container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container1.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {\n            select: true\n          });\n          if (document.activeElement === previouslyFocusedElement) $d3863c46a17e8a28$var$focus(container1);\n        }\n      }\n      return () => {\n        container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus); // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container1.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {\n            select: true\n          });\n          // we need to remove the listener after we `dispatchEvent`\n          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container1, onMountAutoFocus, onUnmountAutoFocus, focusScope]); // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = $45QHv$useCallback(event => {\n    if (!loop && !trapped) return;\n    if (focusScope.paused) return;\n    const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n    const focusedElement = document.activeElement;\n    if (isTabKey && focusedElement) {\n      const container = event.currentTarget;\n      const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container);\n      const hasTabbableElementsInside = first && last; // we can only wrap focus if we have tabbable edges\n      if (!hasTabbableElementsInside) {\n        if (focusedElement === container) event.preventDefault();\n      } else {\n        if (!event.shiftKey && focusedElement === last) {\n          event.preventDefault();\n          if (loop) $d3863c46a17e8a28$var$focus(first, {\n            select: true\n          });\n        } else if (event.shiftKey && focusedElement === first) {\n          event.preventDefault();\n          if (loop) $d3863c46a17e8a28$var$focus(last, {\n            select: true\n          });\n        }\n      }\n    }\n  }, [loop, trapped, focusScope.paused]);\n  return /*#__PURE__*/$45QHv$createElement($45QHv$Primitive.div, $45QHv$babelruntimehelpersesmextends({\n    tabIndex: -1\n  }, scopeProps, {\n    ref: composedRefs,\n    onKeyDown: handleKeyDown\n  }));\n});\n/*#__PURE__*/\nObject.assign($d3863c46a17e8a28$export$20e40289641fbbb6, {\n  displayName: $d3863c46a17e8a28$var$FOCUS_SCOPE_NAME\n});\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/ /**\n                                                                                                     * Attempts focusing the first element in a list of candidates.\n                                                                                                     * Stops when focus has actually moved.\n                                                                                                     */\nfunction $d3863c46a17e8a28$var$focusFirst(candidates, {\n  select = false\n} = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    $d3863c46a17e8a28$var$focus(candidate, {\n      select: select\n    });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction $d3863c46a17e8a28$var$getTabbableEdges(container) {\n  const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);\n  const first = $d3863c46a17e8a28$var$findVisible(candidates, container);\n  const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);\n  return [first, last];\n}\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction $d3863c46a17e8a28$var$getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP; // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode); // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction $d3863c46a17e8a28$var$findVisible(elements, container) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!$d3863c46a17e8a28$var$isHidden(element, {\n      upTo: container\n    })) return element;\n  }\n}\nfunction $d3863c46a17e8a28$var$isHidden(node, {\n  upTo: upTo\n}) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement;\n  }\n  return false;\n}\nfunction $d3863c46a17e8a28$var$isSelectableInput(element) {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\nfunction $d3863c46a17e8a28$var$focus(element, {\n  select = false\n} = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement; // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({\n      preventScroll: true\n    }); // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select) element.select();\n  }\n}\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\nconst $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();\nfunction $d3863c46a17e8a28$var$createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */let stack = [];\n  return {\n    add(focusScope) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n    remove(focusScope) {\n      var _stack$;\n      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();\n    }\n  };\n}\nfunction $d3863c46a17e8a28$var$arrayRemove(array, item) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) updatedArray.splice(index, 1);\n  return updatedArray;\n}\nfunction $d3863c46a17e8a28$var$removeLinks(items) {\n  return items.filter(item => item.tagName !== 'A');\n}\nconst $d3863c46a17e8a28$export$be92b6f5f03c0fe9 = $d3863c46a17e8a28$export$20e40289641fbbb6;\nexport { $d3863c46a17e8a28$export$20e40289641fbbb6 as FocusScope, $d3863c46a17e8a28$export$be92b6f5f03c0fe9 as Root };\n//# sourceMappingURL=index.mjs.map","map":{"version":3,"names":["$45QHv$babelruntimehelpersesmextends","forwardRef","$45QHv$forwardRef","useState","$45QHv$useState","useRef","$45QHv$useRef","useEffect","$45QHv$useEffect","useCallback","$45QHv$useCallback","createElement","$45QHv$createElement","useComposedRefs","$45QHv$useComposedRefs","Primitive","$45QHv$Primitive","useCallbackRef","$45QHv$useCallbackRef","$d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT","$d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT","$d3863c46a17e8a28$var$EVENT_OPTIONS","bubbles","cancelable","$d3863c46a17e8a28$var$FOCUS_SCOPE_NAME","$d3863c46a17e8a28$export$20e40289641fbbb6","props","forwardedRef","loop","trapped","onMountAutoFocus","onMountAutoFocusProp","onUnmountAutoFocus","onUnmountAutoFocusProp","scopeProps","container1","setContainer","lastFocusedElementRef","composedRefs","node","focusScope","paused","pause","resume","current","handleFocusIn","event","target","contains","$d3863c46a17e8a28$var$focus","select","handleFocusOut","relatedTarget","handleMutations","mutations","focusedElement","document","activeElement","body","mutation","removedNodes","length","addEventListener","mutationObserver","MutationObserver","observe","childList","subtree","removeEventListener","disconnect","$d3863c46a17e8a28$var$focusScopesStack","add","previouslyFocusedElement","hasFocusedCandidate","mountEvent","CustomEvent","dispatchEvent","defaultPrevented","$d3863c46a17e8a28$var$focusFirst","$d3863c46a17e8a28$var$removeLinks","$d3863c46a17e8a28$var$getTabbableCandidates","setTimeout","unmountEvent","remove","handleKeyDown","isTabKey","key","altKey","ctrlKey","metaKey","container","currentTarget","first","last","$d3863c46a17e8a28$var$getTabbableEdges","hasTabbableElementsInside","preventDefault","shiftKey","div","tabIndex","ref","onKeyDown","Object","assign","displayName","candidates","candidate","$d3863c46a17e8a28$var$findVisible","reverse","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","FILTER_ACCEPT","nextNode","push","currentNode","elements","element","$d3863c46a17e8a28$var$isHidden","upTo","getComputedStyle","visibility","undefined","display","parentElement","$d3863c46a17e8a28$var$isSelectableInput","HTMLInputElement","focus","preventScroll","$d3863c46a17e8a28$var$createFocusScopesStack","stack","activeFocusScope","$d3863c46a17e8a28$var$arrayRemove","unshift","_stack$","array","item","updatedArray","index","indexOf","splice","items","filter","$d3863c46a17e8a28$export$be92b6f5f03c0fe9","FocusScope","Root"],"sources":["/Users/stefanoramirez/Documents/angularSignatureGenerator/node_modules/@radix-ui/react-focus-scope/dist/index.mjs"],"sourcesContent":["import $45QHv$babelruntimehelpersesmextends from \"@babel/runtime/helpers/esm/extends\";\nimport {forwardRef as $45QHv$forwardRef, useState as $45QHv$useState, useRef as $45QHv$useRef, useEffect as $45QHv$useEffect, useCallback as $45QHv$useCallback, createElement as $45QHv$createElement} from \"react\";\nimport {useComposedRefs as $45QHv$useComposedRefs} from \"@radix-ui/react-compose-refs\";\nimport {Primitive as $45QHv$Primitive} from \"@radix-ui/react-primitive\";\nimport {useCallbackRef as $45QHv$useCallbackRef} from \"@radix-ui/react-use-callback-ref\";\n\n\n\n\n\n\nconst $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst $d3863c46a17e8a28$var$EVENT_OPTIONS = {\n    bubbles: false,\n    cancelable: true\n};\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/ const $d3863c46a17e8a28$var$FOCUS_SCOPE_NAME = 'FocusScope';\nconst $d3863c46a17e8a28$export$20e40289641fbbb6 = /*#__PURE__*/ $45QHv$forwardRef((props, forwardedRef)=>{\n    const { loop: loop = false , trapped: trapped = false , onMountAutoFocus: onMountAutoFocusProp , onUnmountAutoFocus: onUnmountAutoFocusProp , ...scopeProps } = props;\n    const [container1, setContainer] = $45QHv$useState(null);\n    const onMountAutoFocus = $45QHv$useCallbackRef(onMountAutoFocusProp);\n    const onUnmountAutoFocus = $45QHv$useCallbackRef(onUnmountAutoFocusProp);\n    const lastFocusedElementRef = $45QHv$useRef(null);\n    const composedRefs = $45QHv$useComposedRefs(forwardedRef, (node)=>setContainer(node)\n    );\n    const focusScope = $45QHv$useRef({\n        paused: false,\n        pause () {\n            this.paused = true;\n        },\n        resume () {\n            this.paused = false;\n        }\n    }).current; // Takes care of trapping focus if focus is moved outside programmatically for example\n    $45QHv$useEffect(()=>{\n        if (trapped) {\n            function handleFocusIn(event) {\n                if (focusScope.paused || !container1) return;\n                const target = event.target;\n                if (container1.contains(target)) lastFocusedElementRef.current = target;\n                else $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n                    select: true\n                });\n            }\n            function handleFocusOut(event) {\n                if (focusScope.paused || !container1) return;\n                const relatedTarget = event.relatedTarget; // A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:\n                //\n                // 1. When the user switches app/tabs/windows/the browser itself loses focus.\n                // 2. In Google Chrome, when the focused element is removed from the DOM.\n                //\n                // We let the browser do its thing here because:\n                //\n                // 1. The browser already keeps a memory of what's focused for when the page gets refocused.\n                // 2. In Google Chrome, if we try to focus the deleted focused element (as per below), it\n                //    throws the CPU to 100%, so we avoid doing anything for this reason here too.\n                if (relatedTarget === null) return; // If the focus has moved to an actual legitimate element (`relatedTarget !== null`)\n                // that is outside the container, we move focus to the last valid focused element inside.\n                if (!container1.contains(relatedTarget)) $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n                    select: true\n                });\n            } // When the focused element gets removed from the DOM, browsers move focus\n            // back to the document.body. In this case, we move focus to the container\n            // to keep focus trapped correctly.\n            function handleMutations(mutations) {\n                const focusedElement = document.activeElement;\n                if (focusedElement !== document.body) return;\n                for (const mutation of mutations)if (mutation.removedNodes.length > 0) $d3863c46a17e8a28$var$focus(container1);\n            }\n            document.addEventListener('focusin', handleFocusIn);\n            document.addEventListener('focusout', handleFocusOut);\n            const mutationObserver = new MutationObserver(handleMutations);\n            if (container1) mutationObserver.observe(container1, {\n                childList: true,\n                subtree: true\n            });\n            return ()=>{\n                document.removeEventListener('focusin', handleFocusIn);\n                document.removeEventListener('focusout', handleFocusOut);\n                mutationObserver.disconnect();\n            };\n        }\n    }, [\n        trapped,\n        container1,\n        focusScope.paused\n    ]);\n    $45QHv$useEffect(()=>{\n        if (container1) {\n            $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);\n            const previouslyFocusedElement = document.activeElement;\n            const hasFocusedCandidate = container1.contains(previouslyFocusedElement);\n            if (!hasFocusedCandidate) {\n                const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n                container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n                container1.dispatchEvent(mountEvent);\n                if (!mountEvent.defaultPrevented) {\n                    $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {\n                        select: true\n                    });\n                    if (document.activeElement === previouslyFocusedElement) $d3863c46a17e8a28$var$focus(container1);\n                }\n            }\n            return ()=>{\n                container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus); // We hit a react bug (fixed in v17) with focusing in unmount.\n                // We need to delay the focus a little to get around it for now.\n                // See: https://github.com/facebook/react/issues/17894\n                setTimeout(()=>{\n                    const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n                    container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n                    container1.dispatchEvent(unmountEvent);\n                    if (!unmountEvent.defaultPrevented) $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {\n                        select: true\n                    });\n                     // we need to remove the listener after we `dispatchEvent`\n                    container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n                    $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);\n                }, 0);\n            };\n        }\n    }, [\n        container1,\n        onMountAutoFocus,\n        onUnmountAutoFocus,\n        focusScope\n    ]); // Takes care of looping focus (when tabbing whilst at the edges)\n    const handleKeyDown = $45QHv$useCallback((event)=>{\n        if (!loop && !trapped) return;\n        if (focusScope.paused) return;\n        const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n        const focusedElement = document.activeElement;\n        if (isTabKey && focusedElement) {\n            const container = event.currentTarget;\n            const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container);\n            const hasTabbableElementsInside = first && last; // we can only wrap focus if we have tabbable edges\n            if (!hasTabbableElementsInside) {\n                if (focusedElement === container) event.preventDefault();\n            } else {\n                if (!event.shiftKey && focusedElement === last) {\n                    event.preventDefault();\n                    if (loop) $d3863c46a17e8a28$var$focus(first, {\n                        select: true\n                    });\n                } else if (event.shiftKey && focusedElement === first) {\n                    event.preventDefault();\n                    if (loop) $d3863c46a17e8a28$var$focus(last, {\n                        select: true\n                    });\n                }\n            }\n        }\n    }, [\n        loop,\n        trapped,\n        focusScope.paused\n    ]);\n    return /*#__PURE__*/ $45QHv$createElement($45QHv$Primitive.div, $45QHv$babelruntimehelpersesmextends({\n        tabIndex: -1\n    }, scopeProps, {\n        ref: composedRefs,\n        onKeyDown: handleKeyDown\n    }));\n});\n/*#__PURE__*/ Object.assign($d3863c46a17e8a28$export$20e40289641fbbb6, {\n    displayName: $d3863c46a17e8a28$var$FOCUS_SCOPE_NAME\n});\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/ /**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */ function $d3863c46a17e8a28$var$focusFirst(candidates, { select: select = false  } = {}) {\n    const previouslyFocusedElement = document.activeElement;\n    for (const candidate of candidates){\n        $d3863c46a17e8a28$var$focus(candidate, {\n            select: select\n        });\n        if (document.activeElement !== previouslyFocusedElement) return;\n    }\n}\n/**\n * Returns the first and last tabbable elements inside a container.\n */ function $d3863c46a17e8a28$var$getTabbableEdges(container) {\n    const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);\n    const first = $d3863c46a17e8a28$var$findVisible(candidates, container);\n    const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);\n    return [\n        first,\n        last\n    ];\n}\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */ function $d3863c46a17e8a28$var$getTabbableCandidates(container) {\n    const nodes = [];\n    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n        acceptNode: (node)=>{\n            const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n            if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP; // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n            // runtime's understanding of tabbability, so this automatically accounts\n            // for any kind of element that could be tabbed to.\n            return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n        }\n    });\n    while(walker.nextNode())nodes.push(walker.currentNode); // we do not take into account the order of nodes with positive `tabIndex` as it\n    // hinders accessibility to have tab order different from visual order.\n    return nodes;\n}\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */ function $d3863c46a17e8a28$var$findVisible(elements, container) {\n    for (const element of elements){\n        // we stop checking if it's hidden at the `container` level (excluding)\n        if (!$d3863c46a17e8a28$var$isHidden(element, {\n            upTo: container\n        })) return element;\n    }\n}\nfunction $d3863c46a17e8a28$var$isHidden(node, { upTo: upTo  }) {\n    if (getComputedStyle(node).visibility === 'hidden') return true;\n    while(node){\n        // we stop at `upTo` (excluding it)\n        if (upTo !== undefined && node === upTo) return false;\n        if (getComputedStyle(node).display === 'none') return true;\n        node = node.parentElement;\n    }\n    return false;\n}\nfunction $d3863c46a17e8a28$var$isSelectableInput(element) {\n    return element instanceof HTMLInputElement && 'select' in element;\n}\nfunction $d3863c46a17e8a28$var$focus(element, { select: select = false  } = {}) {\n    // only focus if that element is focusable\n    if (element && element.focus) {\n        const previouslyFocusedElement = document.activeElement; // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n        element.focus({\n            preventScroll: true\n        }); // only select if its not the same element, it supports selection and we need to select\n        if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select) element.select();\n    }\n}\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/ const $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();\nfunction $d3863c46a17e8a28$var$createFocusScopesStack() {\n    /** A stack of focus scopes, with the active one at the top */ let stack = [];\n    return {\n        add (focusScope) {\n            // pause the currently active focus scope (at the top of the stack)\n            const activeFocusScope = stack[0];\n            if (focusScope !== activeFocusScope) activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();\n             // remove in case it already exists (because we'll re-add it at the top of the stack)\n            stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n            stack.unshift(focusScope);\n        },\n        remove (focusScope) {\n            var _stack$;\n            stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n            (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();\n        }\n    };\n}\nfunction $d3863c46a17e8a28$var$arrayRemove(array, item) {\n    const updatedArray = [\n        ...array\n    ];\n    const index = updatedArray.indexOf(item);\n    if (index !== -1) updatedArray.splice(index, 1);\n    return updatedArray;\n}\nfunction $d3863c46a17e8a28$var$removeLinks(items) {\n    return items.filter((item)=>item.tagName !== 'A'\n    );\n}\nconst $d3863c46a17e8a28$export$be92b6f5f03c0fe9 = $d3863c46a17e8a28$export$20e40289641fbbb6;\n\n\n\n\nexport {$d3863c46a17e8a28$export$20e40289641fbbb6 as FocusScope, $d3863c46a17e8a28$export$be92b6f5f03c0fe9 as Root};\n//# sourceMappingURL=index.mjs.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}